# 🌐 ASP.NET Core Development Guidelines

This directory contains rules for building high-performance, secure, and maintainable ASP.NET Core applications with modern patterns and best practices.

## 🚀 [ASP.NET Core API Development](aspnet-api.mdc)

Use these rules when:
- 🏗️ Building RESTful APIs with ASP.NET Core
- 🔄 Creating web services and microservices
- 📊 Implementing data access with Entity Framework Core
- 🔐 Adding authentication and authorization
- ⚡ Optimizing API performance and scalability

These rules ensure:
- 🎯 **Minimal APIs** for clean, efficient endpoint definitions
- 🛡️ **Comprehensive security** with JWT authentication and proper CORS
- 📊 **Efficient data access** patterns with EF Core and query optimization
- 🔄 **Async operations** for non-blocking I/O and better scalability
- 📖 **OpenAPI documentation** with Swagger integration
- 🧪 **Testable architecture** with dependency injection
- 📈 **Performance optimization** with caching and background processing

## ⚡ [ASP.NET Core API with Fast Endpoints](aspnet-api-fast-endpoints.mdc)

Use these rules when:
- 🚀 Building high-performance APIs with Fast Endpoints
- 🏆 Seeking developer-friendly alternatives to traditional controllers
- 📋 Implementing comprehensive validation and error handling
- 🔧 Setting up streamlined API development workflows
- 🎨 Creating maintainable endpoint architectures

These rules promote:
- ⚡ **Superior performance** compared to traditional controllers and Minimal APIs
- 🏗️ **Clean architecture** with dedicated endpoint classes
- ✅ **Built-in validation** with automatic model binding and validation
- 📚 **Automatic documentation** generation with OpenAPI/Swagger
- 🔄 **Dependency injection** support and testability
- 🎯 **Strongly-typed** request/response objects
- 📊 **Comprehensive error handling** with proper HTTP status codes

## ☁️ [Microsoft Orleans](aspnet-orleans.mdc)

Use these rules when:
- 🏗️ Building distributed systems with Orleans
- 📈 Scaling applications horizontally across multiple servers
- 🎯 Implementing actor-based programming patterns
- 💾 Managing state persistence and recovery
- 🔄 Handling complex distributed workflows
- 🧪 Testing distributed application components

These rules ensure:
- 🎭 **Proper grain design** with clear interfaces and lifecycle management
- 💾 **Efficient state management** with persistent storage patterns
- 🔄 **Optimized communication** using ValueTask and stream providers
- 🛡️ **Resilience patterns** with circuit breakers and retry logic
- ⚡ **Performance optimization** with grain activation management
- 🧪 **Comprehensive testing** with Orleans test clusters
- 📊 **Monitoring and observability** with health checks and metrics
- 🏗️ **.NET Aspire integration** for streamlined local development
